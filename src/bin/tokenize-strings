#!CONFIG_BASH_COMMAND

#HELP:CONFIG_SUBJECT_NAME: convert a set of strings into tokenized values, one per line
#HELP:Usage: CONFIG_SUBJECT_NAME $string1 $string2 ...

. 'CONFIG_BASH_DIR'/common.bash
. 'CONFIG_BASH_DIR'/opt_help.bash
. 'CONFIG_BASH_DIR'/opt_verbose.bash
. 'CONFIG_BASH_DIR'/fail.bash

#HELP:Options:
#HELP:  --help | -h: Print this help

#HELP:  --input-separator=$char | -i $char: tokenize input as separated by $char
#HELP:      Default is blank (''), which does not tokenize input
default_input_separator=''
unset input_separator
opt_input_separator () {
    [[ ${input_separator+is-set} != is-set ]] || fail "option --input-separator may only occur once" 
    (( $# == 1 )) || fail "function $FUNCNAME requires 1 arg (got $#)"
    (( ${#1} <= 1 )) || fail "input separator must be a empty or a single character (got ${#1})"
    input_separator="$1"
}

#HELP:  --output-separator=$string | -o $string: on output, separate tokens by $string
#HELP:      Default is newline. Use blank ('') for null-separated output. Use : for PATHs
default_output_separator=$'\n'
unset output_separator
opt_output_separator () {
    [[ ${output_separator+is-set} != is-set ]] || fail "option --output-separator may only occur once" 
    (( $# == 1 )) || fail "function $FUNCNAME requires 1 arg (got $#)"
    output_separator="$1"
}

OPTIND=1
while getopts :hi:o:-: option
do case "$option" in
       h ) opt_help;;
       i ) opt_input_separator "$OPTARG";;
       o ) opt_output_separator "$OPTARG";;
       - ) case "$OPTARG" in
               help ) opt_help;;
               input-separator=* ) opt_input_separator "${OPTARG#*=}";;
               output-separator=* ) opt_output_separator "${OPTARG#*=}";;
               input-separator | output-separator ) fail "Argument required for long option \"$OPTARG\"";;
               help=* ) fail "Long option \"${OPTARG%%=*}\" has unexpected argument";;
               * ) fail "Unknown long option \"${OPTARG%%=*}\"";;
            esac;;
        '?' ) fail "Unknown short option \"$OPTARG\"";;
        : ) fail "Short option \"$OPTARG\" missing argument";;
        * ) fail_assert "Bad state in getopts (OPTARG=\"$OPTARG\")";;
   esac
done
shift $((OPTIND-1))

if [[ ${input_separator+is-set} != is-set ]]
then vecho Using default input separator
     input_separator=$default_input_separator
fi

if [[ ${output_separator+is-set} != is-set ]]
then vecho Using default output separator
     output_separator=$default_output_separator
fi

has_printed=false
print_separated () {
    (( $# == 1 )) || fail "$FUNCNAME must have 1 arg"
    if [[ $has_printed = true ]]
    then if [[ $output_separator = '' ]]
         then printf '\0'
         else printf "%s" "$output_separator"
         fi
    fi
    printf "%s" "$1"
    has_printed=true
}

for string in "$@"
do
    if [[ $input_separator = "" ]]
    then print_separated "$string"
    else while read -r -d "$input_separator"
         do print_separated "$REPLY"
         done <<< "$string$input_separator"
    fi
done

m4_dnl Local Variables:
m4_dnl mode: shell-script
m4_dnl eval: (sh-set-shell "bash")
m4_dnl indent-tabs-mode: nil
m4_dnl fill-column: 9999
m4_dnl End:
